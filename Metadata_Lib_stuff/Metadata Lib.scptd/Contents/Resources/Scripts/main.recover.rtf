{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fnil\fcharset0 Verdana-Bold;\f1\fnil\fcharset0 Verdana;\f2\fnil\fcharset0 Verdana-Italic;
}
{\colortbl;\red255\green255\blue255;\red108\green5\blue211;\red0\green0\blue255;\red77\green78\blue78;
\red64\green128\blue0;\red251\green0\blue7;}
{\*\expandedcolortbl;;\csgenericrgb\c42300\c1800\c82800;\csgenericrgb\c0\c0\c99819;\csgenericrgb\c30000\c30500\c30500;
\csgenericrgb\c25000\c50000\c0;\cssrgb\c100000\c0\c0;}
\deftab480
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 use
\f1\b0 \cf0  \cf2 AppleScript\cf0  \cf3 version\cf0  \cf0 "2.4"\cf0  
\f2\i \cf4 -- 10.10 or later
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 use
\f1\b0 \cf0  
\f2\i \cf3 framework
\f1\i0 \cf0  \cf0 "Foundation"\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- These first four handlers are all you need to use. See the library's dictionary for details.
\f1\i0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  
\f0\b \cf3 perform search
\f1\b0 \cf0  \cf3 predicate string\cf0  \cf5 predString\cf0  \cf3 in folders\cf0  \cf5 filesAliasesURLsOrPosixPaths\cf0  : 
\f2\i \cf3 missing value
\f1\i0 \cf0  \cf3 just in\cf0  \cf5 fileAliasURLOrPosixPath\cf0  : 
\f2\i \cf3 missing value
\f1\i0 \cf0  \cf3 in scopes\cf0  \cf5 listOfScopes\cf0  : 
\f2\i \cf3 missing value
\f1\i0 \cf0  \cf3 search arguments\cf0  \cf5 argList\cf0  : \{\} \cf3 attributes to include\cf0  \cf5 attList\cf0  : 
\f2\i \cf3 missing value
\f1\i0 \cf0  \cf3 converting dates\cf0  \cf5 datesFlag\cf0  : \cf2 false\cf0  \cf3 names only\cf0  \cf5 namesFlag\cf0  : \cf2 false\cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 filesAliasesURLsOrPosixPaths\cf0  
\f0\b \cf0 is
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 fileAliasURLOrPosixPath\cf0  
\f0\b \cf0 is
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0  \cf6 namesOnly\cf0 :\cf5 namesFlag\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 listOfScopes\cf0  
\f0\b \cf0 is
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchIn\cf0 :\cf5 listOfScopes\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0 \
		
\f0\b \cf0 error
\f1\b0 \cf0  \cf0 "You must specify one of the 'in folders', 'just in' or 'in scope' parameters."\cf0  \cf3 from\cf0  
\f0\b \cf0 me
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf3 perform search
\f1\b0 \cf0 \
\

\f0\b \cf0 on
\f1\b0 \cf0  
\f0\b \cf3 metadata scope strings
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf0 "kMDQueryScopeHome"\cf0 , \cf0 "kMDQueryScopeNetwork"\cf0 , \cf0 "kMDQueryScopeComputer"\cf0 , \cf0 "kMDQueryScopeAllIndexed"\cf0 , \cf0 "kMDQueryScopeComputerIndexed"\cf0 , \cf0 "kMDQueryScopeNetworkIndexed"\cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf3 metadata scope strings
\f1\b0 \cf0 \
\

\f0\b \cf0 on
\f1\b0 \cf0  
\f0\b \cf3 fetch metadata
\f1\b0 \cf0  \cf3 for item\cf0  \cf5 fileAliasURLOrPosixPath\cf0  \cf3 return style\cf0  \cf5 returnStyle\cf0  : \cf2 metadata record\cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 returnStyle\cf0  = \cf2 metadata record\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 fetchMetadataFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 returnStyle\cf0  = \cf2 metadata keys\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 fetchMetadataKeysFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 returnStyle\cf0  = \cf2 metadata keys and values\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 fetchMetadataKeysAndValuesFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 returnStyle\cf0  = \cf2 metadata all\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 fetchMetadataAllFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 fetchMetadataFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf3 fetch metadata
\f1\b0 \cf0 \
\

\f0\b \cf0 on
\f1\b0 \cf0  
\f0\b \cf3 search strings from saved search
\f1\b0 \cf0  \cf5 posixPath\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchStringsFromSavedSearch\cf0 :\cf5 posixPath\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf3 search strings from saved search
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 ######### The handlers below are called by the above. They are mostly kept separate for compatibility with version 1.0 of this library, but can be called directly if you prefer.
\f1\i0 \cf0 \
\

\f2\i \cf4 #### Spotlight query handlers.
\f1\i0 \cf0 \
\

\f2\i \cf4 (*\
These handlers all accept either an alias, file, NSURL or POSIX path.\
\
Example:\
 \
use scripting additions\
use mdLib : script "Metadata Lib" version "2.0"\
\
set theFile to choose file\
set theRecord to mdLib's fetchMetadataFor:theFile \
*)
\f1\i0 \cf0 \
\

\f2\i \cf4 -- This returns the metadata for an item as a record.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 fetchMetadataFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mdItem\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _mdItemFrom\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 mdItem's\cf0  \cf6 valuesForAttributes\cf0 :(\cf5 mdItem's\cf0  \cf6 attributes\cf0 ())\
	
\f0\b \cf0 considering
\f1\b0 \cf0  \cf2 numeric strings\cf0 \
		
\f0\b \cf0 if
\f1\b0 \cf0  \cf2 AppleScript's\cf0  
\f2\i \cf3 version
\f1\i0 \cf0  < \cf0 "2.5"\cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf0 :\cf5 theMetadata\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 considering
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 record
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 fetchMetadataFor\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This returns a list of the available metadata attribute keys (as strings) for an item.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 fetchMetadataKeysFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mdItem\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _mdItemFrom\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  (\cf5 mdItem's\cf0  \cf6 attributes\cf0 ()) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 fetchMetadataKeysFor\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This returns two matching lists: the available metadata attribute keys (as strings), and the corresponding values.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 fetchMetadataKeysAndValuesFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mdItem\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _mdItemFrom\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theKeys\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 mdItem's\cf0  \cf6 attributes\cf0 ())\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 mdItem's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 theKeys\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theValues\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theMetadata's\cf0  \cf6 objectsForKeys\cf0 :\cf5 theKeys\cf0  \cf6 notFoundMarker\cf0 :\cf0 ""\cf0 \
	
\f0\b \cf0 considering
\f1\b0 \cf0  \cf2 numeric strings\cf0 \
		
\f0\b \cf0 if
\f1\b0 \cf0  \cf2 AppleScript's\cf0  
\f2\i \cf3 version
\f1\i0 \cf0  < \cf0 "2.5"\cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theValues\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 theValues\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 considering
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf5 theKeys\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 , \cf5 theValues\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 fetchMetadataKeysAndValuesFor\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This returns two lists and a record: the available metadata attribute keys (as strings), the corresponding values, plus the same information as a record.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 fetchMetadataAllFor\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mdItem\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _mdItemFrom\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theKeys\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 mdItem's\cf0  \cf6 attributes\cf0 ())\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 mdItem's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 theKeys\cf0 \
	
\f0\b \cf0 considering
\f1\b0 \cf0  \cf2 numeric strings\cf0 \
		
\f0\b \cf0 if
\f1\b0 \cf0  \cf2 AppleScript's\cf0  
\f2\i \cf3 version
\f1\i0 \cf0  < \cf0 "2.5"\cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMetadata\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf0 :\cf5 theMetadata\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 considering
\f1\b0 \cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theValues\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theMetadata's\cf0  \cf6 objectsForKeys\cf0 :\cf5 theKeys\cf0  \cf6 notFoundMarker\cf0 :\cf0 ""\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf5 theKeys\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 , \cf5 theValues\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 , \cf5 theMetadata\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 record
\f1\i0 \cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 fetchMetadataAllFor\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 #### Spotlight search handlers.
\f1\i0 \cf0 \
\

\f2\i \cf4 (*\
Spotlight searches with NSMetadataQuery use search strings known as predicate strings. These can be complete searches, such as "kMDItemFSName ENDSWITH[c] '.txt'", or they can use placeholders so you can supply the actual values to be used as arguments separately. The placeholders are %K for an attribute and %@ for a value, and the arguments are provided as a single list in the order of appearance. *** See the "Utilities handlers" section below for more information on predicate strings. ***\
\
These predicate combinations are identical:\
... searchString:"kMDItemFSName ENDSWITH[c] '.txt'" searchArgs:\{\} ...\
... searchString:"kMDItemFSName ENDSWITH[c] %@" searchArgs:\{".txt"\} ... (no quotes around the placeholder)\
... searchString:"%K ENDSWITH[c] %@" searchArgs:\{"kMDItemFSName", ".txt"\} ...\
... searchString:"%K ENDSWITH[c] %@" searchArgs:\{current application's NSMetadataItemFSNameKey, ".txt"\} ... (must be run from AppleScriptObjC script)\
\
You need to be running 10.11 or later when using AppleScript dates in predicates. For example:\
mdLib's searchFolders:\{posixPath\} searchString:"kMDItemFSContentChangeDate > %@" searchArgs:\{(current date) - 7 * days\}\
\
*)
\f1\i0 \cf0 \
\

\f2\i \cf4 #### Basic search handlers.
\f1\i0 \cf0 \
\

\f2\i \cf4 (*\
The first parameter in each case is a list of places to search. You can pass a list of aliases, files, NSURLs or POSIX paths \'97 pass an empty list for a complete search. If you wish to use search scope constants such as "kMDQueryScopeComputer", pass them in a list to the searchIn: variation.\
The second parameter is the search string -- for example, "(kMDItemFSName CONTAINS[c] %@)".\
The third parameter is a list of arguments to be substituted for any %K and %@ placeholders in the search string. If placeholders are not used, pass an empty list.\
The result is a list of POSIX paths.\
\
Example:\
\
use scripting additions\
use mdLib : script "Metadata Lib" version "2.0"\
\
set theFolder to choose folder\
set theFiles to mdLib's searchFolders:\{theFolder\} searchString:"kMDItemFSName ENDSWITH[c] %@" searchArgs:\{".txt"\}\
*)
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :(
\f2\i \cf3 missing value
\f1\i0 \cf0 )\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchFolders\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Use this version if you want to limit the results to items directly within a single folder
\f1\i0 \cf0 \

\f2\i \cf4 (*\
Example:\
\
use scripting additions\
use mdLib : script "Metadata Lib" version "2.0"\
\
set theFolder to choose folder\
set theFiles to mdLib's searchOnlyIn:theFolder searchString:"kMDItemFSName ENDSWITH[c] %@" searchArgs:\{".txt"\}\
*)
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :(
\f2\i \cf3 missing value
\f1\i0 \cf0 ) \cf6 convertDates\cf0 :\cf2 false\cf0  \cf6 namesOnly\cf0 :\cf2 false\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchOnlyIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is identical to the previous method, except the namesFlag: boolean parameter lets you specify that that just the names be returned, rather than the full POSIX paths
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 namesOnly\cf0 :\cf5 namesFlag\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :(
\f2\i \cf3 missing value
\f1\i0 \cf0 ) \cf6 convertDates\cf0 :\cf2 false\cf0  \cf6 namesOnly\cf0 :\cf5 namesFlag\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchOnlyIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 namesOnly\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Use this with one or more of the pre-defined search scopes in a list: "kMDQueryScopeHome", "kMDQueryScopeNetwork", "kMDQueryScopeComputer", "kMDQueryScopeAllIndexed", "kMDQueryScopeComputerIndexed", and "kMDQueryScopeNetworkIndexed". See <https://developer.apple.com/documentation/coreservices/mdquery/query_search_scope_keys?language=objc> for details.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchIn\cf0 :\cf5 listOfScopes\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchIn\cf0 :\cf5 listOfScopes\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :(
\f2\i \cf3 missing value
\f1\i0 \cf0 ) \cf6 convertDates\cf0 :\cf2 false\cf0  \cf6 namesOnly\cf0 :\cf2 false\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 #### Attribute search handlers.
\f1\i0 \cf0 \
\

\f2\i \cf4 (*\
The first parameter in each case is a list of places to search. You can pass a list of aliases, files, NSURLs or POSIX paths \'97 pass an empty list for a complete search. If you wish to use search scope constants such as "kMDQueryScopeComputer", pass them in a list to the searchIn: variation.\
The second parameter is the search string -- for example, "kMDItemFSName CONTAINS[c] %@".\
The third parameter is a list of arguments to be substituted for any %K and %@ placeholders in the search string. If placeholders are not used, pass an empty list.\
The fourth parameter is a list of the attributes you want returned. Pass an empty list if you want a list of records containing all available Spotlight metadata for each file. Otherwise pass a list of just those attribute keys for which you want values returned in the records -- the keys should be in the form of strings, such as "kMDItemContentTypeTree" (if your script uses AppleScriptObjC you can also use the form 'current application's NSMetadataItemContentTypeTreeKey'). The path key ("kMDItemPath") is automatically included whenever records are returned. If you pass a list of attribute keys for which values are not found, the records will include them with a value of 'missing value'. (If you pass 'missing value' as the forAttributes: parameter, the result will instead be a list of just the POSIX paths.)\
The convertDates: parameter is for use when running under macOS 10.9 or 10.10. If true, it will convert any NSDates in the results to AppleScript dates. This can be a time-consuming process when there are a lot of results, so only specify it if the dates matter to you. Under macOS 10.11 and later the system does the conversion automatically so this parameter is ignored there.\
\
Example:\
\
use scripting additions\
use mdLib : script "Metadata Lib" version "2.0"\
\
set theFolder to choose folder\
set fileRecords to mdLib's searchFolders:\{theFolder\} searchString:"kMDItemFSName ENDSWITH[c] %@" searchArgs:\{".txt"\} forAttributes:\{"kMDItemFSSize"\}\
*)
\f1\i0 \cf0 \
\

\f2\i \cf4 -- This is the default search. Pass a list of files, aliases, NSURLs or POSIX paths to be searched.
\f1\i0 \cf0 \

\f2\i \cf4 -- If the results include dates and you're using macOS 10.10 or earlier, you should use the following method which can convert NSDates to AppleScript dates.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf2 false\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchFolders\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is the same as the previous handler, but includes the convertDates: parameter described above.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchFolders\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theURLs\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithArray\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 theURLs's\cf0  \cf6 |count|\cf0 () > \cf0 0\cf0  
\f0\b \cf0 and
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  (\cf5 theURLs's\cf0  \cf6 firstObject\cf0 ()'s \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 |class|\cf0 ())) 
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 1\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf3 count
\f1\b0 \cf0  
\f0\b \cf0 of
\f1\b0 \cf0  \cf5 filesAliasesURLsOrPosixPaths\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  
\f2\i \cf3 item
\f1\i0 \cf0  \cf5 i\cf0  
\f0\b \cf0 of
\f1\b0 \cf0  \cf5 filesAliasesURLsOrPosixPaths\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 fileURLWithPath\cf0 :(\cf2 POSIX path\cf0  
\f0\b \cf0 of
\f1\b0 \cf0  
\f2\i \cf3 item
\f1\i0 \cf0  \cf5 i\cf0  
\f0\b \cf0 of
\f1\b0 \cf0  \cf5 filesAliasesURLsOrPosixPaths\cf0 ))\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchIn\cf0 :\cf5 filesAliasesURLsOrPosixPaths\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchFolders\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf6 convertDates\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Use this version if you want to limit the results to items directly within a single folder.
\f1\i0 \cf0 \

\f2\i \cf4 (*\
Example:\
\
use scripting additions\
use mdLib : script "Metadata Lib" version "2.0"\
\
set theFolder to choose folder\
set fileRecords to mdLib's searchOnlyIn:theFolder searchString:"kMDItemFSName ENDSWITH[c] %@" searchArgs:\{".txt"\} forAttributes:\{"kMDItemFSSize"\}\
*)
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf2 false\cf0  \cf6 namesOnly\cf0 :\cf2 false\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchOnlyIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is the same as the previous handler, but includes the convertDates: parameter described above.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \
	
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0  \cf6 namesOnly\cf0 :\cf2 false\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchOnlyIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf6 convertDates\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is the called by other handlers.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchOnlyIn\cf0 :\cf5 fileAliasURLOrPosixPath\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0  \cf6 namesOnly\cf0 :\cf5 namesFlag\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theURL\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf2 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 )'s \cf6 firstObject\cf0 ()\
	
\f0\b \cf0 if
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  (\cf5 theURL's\cf0  \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 |class|\cf0 ())) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theURL\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 fileURLWithPath\cf0 :(\cf2 POSIX path\cf0  
\f0\b \cf0 of
\f1\b0 \cf0  \cf5 fileAliasURLOrPosixPath\cf0 ))\
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 parentPath\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theURL's\cf0  \cf6 path\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thePred\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat\cf0 :\cf5 predString\cf0  \cf6 argumentArray\cf0 :\cf5 argList\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theQuery\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMetadataQuery's\cf0  \cf6 new\cf0 ()\
	\cf5 theQuery's\cf0  \cf6 setSearchScopes\cf0 :\{\cf5 theURL\cf0 \}\
	\cf5 theQuery's\cf0  \cf6 setPredicate\cf0 :\cf5 thePred\cf0 \
	\cf5 theQuery's\cf0  \cf6 startQuery\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMutableArray's\cf0  \cf6 array\cf0 () 
\f2\i \cf4 -- to collect results
\f1\i0 \cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 pathKey\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf0 "kMDItemPath"\cf0 \
	
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 while
\f1\b0 \cf0  \cf5 theQuery's\cf0  \cf6 isGathering\cf0 () 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0 \
		
\f0\b \cf3 delay
\f1\b0 \cf0  \cf0 0.01\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	\cf5 theQuery's\cf0  \cf6 stopQuery\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theCount\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theQuery's\cf0  \cf6 resultCount\cf0 ()\
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 attList\cf0  = 
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f2\i \cf4 -- only want the paths or names
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thePath\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valueForAttribute\cf0 :\cf5 pathKey\cf0 )\
			
\f0\b \cf0 if
\f1\b0 \cf0  (\cf5 thePath's\cf0  \cf6 stringByDeletingLastPathComponent\cf0 ()'s \cf6 isEqualToString\cf0 :\cf5 parentPath\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
				(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 thePath\cf0 )\
			
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
		
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 namesFlag\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
			
\f0\b \cf0 return
\f1\b0 \cf0  ((\cf5 theResults's\cf0  \cf6 valueForKey\cf0 :\cf0 "lastPathComponent"\cf0 )'s \cf6 sortedArrayUsingSelector\cf0 :\cf0 "caseInsensitiveCompare:"\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \
		
\f0\b \cf0 else
\f1\b0 \cf0 \
			
\f0\b \cf0 return
\f1\b0 \cf0  (\cf5 theResults's\cf0  \cf6 sortedArrayUsingSelector\cf0 :\cf0 "caseInsensitiveCompare:"\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 attList\cf0  = \{\} 
\f0\b \cf0 then
\f1\b0 \cf0  
\f2\i \cf4 -- want all attributes, including path
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 allAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 attributes\cf0 ()'s \cf6 arrayByAddingObject\cf0 :\cf5 pathKey\cf0 ) 
\f2\i \cf4 -- have to add path key
\f1\i0 \cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 attDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 allAtts\cf0 )\
			
\f0\b \cf0 if
\f1\b0 \cf0  ((\cf5 attDict's\cf0  \cf6 objectForKey\cf0 :\cf5 pathKey\cf0 )'s \cf6 stringByDeletingLastPathComponent\cf0 ()'s \cf6 isEqualToString\cf0 :\cf5 parentPath\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
				(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 attDict\cf0 )\
			
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f2\i \cf4 -- just the passed attributes plus path
\f1\i0 \cf0 \
		
\f2\i \cf4 -- add pathKey and remove any duplicates
\f1\i0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 requiredAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf2 current application's\cf0  \cf5 NSMutableSet's\cf0  \cf6 setWithArray\cf0 :\cf5 attList\cf0 )\
		\cf5 requiredAtts's\cf0  \cf6 addObject\cf0 :\cf5 pathKey\cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 requiredAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 requiredAtts's\cf0  \cf6 allObjects\cf0 ()\
		
\f2\i \cf4 -- create a temporary dictionary containing all keys
\f1\i0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 tempDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMutableDictionary's\cf0  \cf6 dictionaryWithCapacity\cf0 :(\cf5 requiredAtts's\cf0  \cf6 |count|\cf0 ())\
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theNull\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSNull's\cf0  \cf6 null\cf0 ()\
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 anAtt\cf0  
\f0\b \cf0 in
\f1\b0 \cf0  \cf5 requiredAtts\cf0 \
			(\cf5 tempDict's\cf0  \cf6 setObject\cf0 :\cf5 theNull\cf0  \cf6 forKey\cf0 :\cf5 anAtt\cf0 )\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
		
\f2\i \cf4 -- loop through
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 attDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 requiredAtts\cf0 )\
			
\f0\b \cf0 if
\f1\b0 \cf0  ((\cf5 attDict's\cf0  \cf6 objectForKey\cf0 :\cf5 pathKey\cf0 )'s \cf6 stringByDeletingLastPathComponent\cf0 ()'s \cf6 isEqualToString\cf0 :\cf5 parentPath\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
				
\f2\i \cf4 -- start with dict containing all keys, then add found values
\f1\i0 \cf0 \
				
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 resultDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 tempDict's\cf0  \cf6 mutableCopy\cf0 ()\
				(\cf5 resultDict's\cf0  \cf6 addEntriesFromDictionary\cf0 :\cf5 attDict\cf0 )\
				(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 resultDict\cf0 )\
			
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 datesFlag\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 considering
\f1\b0 \cf0  \cf2 numeric strings\cf0 \
			
\f0\b \cf0 if
\f1\b0 \cf0  \cf2 AppleScript's\cf0  
\f2\i \cf3 version
\f1\i0 \cf0  < \cf0 "2.5"\cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 theResults\cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 considering
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchOnlyIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf6 convertDates\cf6 :\cf6 namesOnly\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Use this version if passing search scope constants; it always includes the convertDates: parameter
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchIn\cf0 :\cf5 listOfScopes\cf0  \cf6 searchString\cf0 :\cf5 predString\cf0  \cf6 searchArgs\cf0 :\cf5 argList\cf0  \cf6 forAttributes\cf0 :\cf5 attList\cf0  \cf6 convertDates\cf0 :\cf5 datesFlag\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thePred\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat\cf0 :\cf5 predString\cf0  \cf6 argumentArray\cf0 :\cf5 argList\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theQuery\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMetadataQuery's\cf0  \cf6 new\cf0 ()\
	\cf5 theQuery's\cf0  \cf6 setSearchScopes\cf0 :\cf5 listOfScopes\cf0 \
	\cf5 theQuery's\cf0  \cf6 setPredicate\cf0 :\cf5 thePred\cf0 \
	\cf5 theQuery's\cf0  \cf6 startQuery\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMutableArray's\cf0  \cf6 array\cf0 () 
\f2\i \cf4 -- to collect results
\f1\i0 \cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 pathKey\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf0 "kMDItemPath"\cf0 \
	
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 while
\f1\b0 \cf0  \cf5 theQuery's\cf0  \cf6 isGathering\cf0 () 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0 \
		
\f0\b \cf3 delay
\f1\b0 \cf0  \cf0 0.01\cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	\cf5 theQuery's\cf0  \cf6 stopQuery\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theCount\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theQuery's\cf0  \cf6 resultCount\cf0 ()\
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 attList\cf0  = 
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f2\i \cf4 -- only want the paths
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thePath\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valueForAttribute\cf0 :\cf5 pathKey\cf0 )\
			(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 thePath\cf0 )\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
		
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 attList\cf0  = \{\} 
\f0\b \cf0 then
\f1\b0 \cf0  
\f2\i \cf4 -- want all attributes, including path
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 allAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 attributes\cf0 ()'s \cf6 arrayByAddingObject\cf0 :\cf5 pathKey\cf0 ) 
\f2\i \cf4 -- have to add path key
\f1\i0 \cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 attDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 allAtts\cf0 )\
			(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 attDict\cf0 )\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 else
\f1\b0 \cf0  
\f2\i \cf4 -- just the passed attributes plus path
\f1\i0 \cf0 \
		
\f2\i \cf4 -- add pathKey and remove any duplicates
\f1\i0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 requiredAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf2 current application's\cf0  \cf5 NSMutableSet's\cf0  \cf6 setWithArray\cf0 :\cf5 attList\cf0 )\
		\cf5 requiredAtts's\cf0  \cf6 addObject\cf0 :\cf5 pathKey\cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 requiredAtts\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 requiredAtts's\cf0  \cf6 allObjects\cf0 ()\
		
\f2\i \cf4 -- create a temporary dictionary containing all keys
\f1\i0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 tempDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMutableDictionary's\cf0  \cf6 dictionaryWithCapacity\cf0 :(\cf5 requiredAtts's\cf0  \cf6 |count|\cf0 ())\
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theNull\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSNull's\cf0  \cf6 null\cf0 ()\
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 anAtt\cf0  
\f0\b \cf0 in
\f1\b0 \cf0  \cf5 requiredAtts\cf0 \
			(\cf5 tempDict's\cf0  \cf6 setObject\cf0 :\cf5 theNull\cf0  \cf6 forKey\cf0 :\cf5 anAtt\cf0 )\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
		
\f2\i \cf4 -- loop through
\f1\i0 \cf0 \
		
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCount\cf0  - \cf0 1\cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 aResult\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theQuery's\cf0  \cf6 resultAtIndex\cf0 :\cf5 i\cf0 )\
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 attDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 aResult's\cf0  \cf6 valuesForAttributes\cf0 :\cf5 requiredAtts\cf0 )\
			
\f2\i \cf4 -- start with dict containing all keys, then add found values
\f1\i0 \cf0 \
			
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 resultDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 tempDict's\cf0  \cf6 mutableCopy\cf0 ()\
			(\cf5 resultDict's\cf0  \cf6 addEntriesFromDictionary\cf0 :\cf5 attDict\cf0 )\
			(\cf5 theResults's\cf0  \cf6 addObject\cf0 :\cf5 resultDict\cf0 )\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 datesFlag\cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 considering
\f1\b0 \cf0  \cf2 numeric strings\cf0 \
			
\f0\b \cf0 if
\f1\b0 \cf0  \cf2 AppleScript's\cf0  
\f2\i \cf3 version
\f1\i0 \cf0  < \cf0 "2.5"\cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 theResults\cf0 \
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 considering
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 theResults\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchIn\cf6 :\cf6 searchString\cf6 :\cf6 searchArgs\cf6 :\cf6 forAttributes\cf6 :\cf6 convertDates\cf6 :\cf0 \
\
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 #### Utility handlers
\f1\i0 \cf0 \
\

\f2\i \cf4 (*\
Predicate strings are slightly different to the search strings used with 'mdfind'. A predicate string will always have an attribute on the left and a value (or values) on the right. The operators you can use include ==, !=, <>, >, <, >=, <=, LIKE, CONTAINS, BETWEEN, IN, BEGINSWITH and ENDSWITH, and case- and diacritical-insensitivity involve using [c], [cd] or [d] after the operator. You can use AND and OR as joiners, as well as their equivalents && and ||. Operators are typically written in uppercase, but they do not have to be. You can read more here: <https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Predicates/Articles/pSpotlightComparison.html>. You can also see a list of some of the common metadata keys here: <https://developer.apple.com/library/content/documentation/CoreServices/Reference/MetadataAttributesRef/Reference/CommonAttrs.html>.\
One way to build predicate strings is to do a find in Finder and save the search. You can then pass the POSIX path of the .savedSearch file to the searchStringFromSavedSearch: handler below, and it will return a predicate string. Depending on the search you will probably need to modify some values, but it provides a good starting point.\
*)
\f1\i0 \cf0 \
\

\f2\i \cf4 -- Pass the POSIX path to a saved Finder search file (.savedSearch). Returns a list of two strings: the raw mdfind-style query used by the Finder, and the predicate string near-equivalent.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 searchStringsFromSavedSearch\cf0 :\cf5 posixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 posixPath\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSString's\cf0  \cf6 stringWithString\cf0 :\cf5 posixPath\cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  
\f0\b \cf0 not
\f1\b0 \cf0  (\cf5 posixPath's\cf0  \cf6 pathExtension\cf0 ()'s \cf6 isEqualToString\cf0 :\cf0 "savedSearch"\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 error
\f1\b0 \cf0  \cf0 "File is not a saved search"\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theData\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 the
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSData's\cf0  \cf6 dataWithContentsOfFile\cf0 :\cf5 posixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \{\cf5 theDict\cf0 , \cf5 theError\cf0 \} 
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSPropertyListSerialization's\cf0  \cf6 propertyListWithData\cf0 :\cf5 theData\cf0  \cf6 options\cf0 :(\cf2 current application's\cf0  \cf5 NSPropertyListMutableContainersAndLeaves\cf0 ) \cf6 format\cf0 :(
\f2\i \cf3 missing value
\f1\i0 \cf0 ) \cf6 |error|\cf0 :(
\f2\i \cf3 reference
\f1\i0 \cf0 )\
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 theDict\cf0  = 
\f2\i \cf3 missing value
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0  
\f0\b \cf0 error
\f1\b0 \cf0  (\cf5 theError's\cf0  \cf6 localizedDescription\cf0 () 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 text
\f1\i0 \cf0 )\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theRawQuery\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theDict's\cf0  \cf6 valueForKey\cf0 :\cf0 "RawQuery"\cf0 )\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thePred\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateFromMetadataQueryString\cf0 :\cf5 theRawQuery\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf5 theRawQuery\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 text
\f1\i0 \cf0 , \cf5 thePred's\cf0  \cf6 predicateFormat\cf0 () 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 text
\f1\i0 \cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 searchStringsFromSavedSearch\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is a convenience handler that takes an AppleScript record and returns its labels (as strings) and values as two separate lists.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 keysAndValuesForRecord\cf0 :\cf5 aRecord\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSDictionary's\cf0  \cf6 dictionaryWithDictionary\cf0 :\cf5 aRecord\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theKeys\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theDict's\cf0  \cf6 attributes\cf0 ())\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theValues\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 objectsForKeys\cf0 :\cf5 theKeys\cf0  \cf6 notFoundMarker\cf0 :\cf0 ""\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf5 theKeys\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 , \cf5 theValues\cf0  
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 keysAndValuesForRecord\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- This is here to save you having to look them up
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 metadataScopeConstants\cf0 ()\
	
\f0\b \cf0 return
\f1\b0 \cf0  \{\cf0 "kMDQueryScopeHome"\cf0 , \cf0 "kMDQueryScopeNetwork"\cf0 , \cf0 "kMDQueryScopeComputer"\cf0 , \cf0 "kMDQueryScopeAllIndexed"\cf0 , \cf0 "kMDQueryScopeComputerIndexed"\cf0 , \cf0 "kMDQueryScopeNetworkIndexed"\cf0 , \cf0 "See <https://developer.apple.com/documentation/coreservices/mdquery/query_search_scope_keys?language=objc> for details"\cf0 \}\

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 metadataScopeConstants\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- If you pass a record, it will be passed back with any NSDates converted to their AppleScript date equivalents
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 convertDatesInRecord\cf0 :\cf5 theRecord\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSDictionary's\cf0  \cf6 dictionaryWithDictionary\cf0 :\cf5 theRecord\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  (
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf0 :\cf5 theDict\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 record
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 convertDatesInRecord\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- If you pass a list, it will be passed back with any NSDates converted to their AppleScript date equivalents
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 convertDatesInList\cf0 :\cf5 theList\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theArray\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithArray\cf0 :\cf5 theArray\cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  (
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 theArray\cf0 ) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 list
\f1\i0 \cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 convertDatesInList\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Used for conversion of dates
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf0 :\cf5 theDict\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mutDict\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 mutableCopy\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theKeys\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 mutDict's\cf0  \cf6 allKeys\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theValues\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 mutDict's\cf0  \cf6 objectsForKeys\cf0 :\cf5 theKeys\cf0  \cf6 notFoundMarker\cf0 :\cf0 ""\cf0 \
	
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theValues's\cf0  \cf6 |count|\cf0 ()) - \cf0 1\cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thisValue\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theValues's\cf0  \cf6 objectAtIndex\cf0 :\cf5 i\cf0 )\
		
\f0\b \cf0 if
\f1\b0 \cf0  (\cf5 thisValue's\cf0  \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 NSDate\cf0 )) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
			(\cf5 mutDict's\cf0  \cf6 setObject\cf0 :(
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _makeASDateFrom\cf0 :\cf5 thisValue\cf0 ) \cf6 forKey\cf0 :(\cf5 theKeys's\cf0  \cf6 objectAtIndex\cf0 :\cf5 i\cf0 ))\
		
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  (\cf5 thisValue's\cf0  \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 NSArray\cf0 )) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
			(\cf5 mutDict's\cf0  \cf6 setObject\cf0 :(
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 thisValue\cf0 ) \cf6 forKey\cf0 :(\cf5 theKeys's\cf0  \cf6 objectAtIndex\cf0 :\cf5 i\cf0 ))\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 mutDict\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Used for conversion of dates
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf0 :\cf5 theArray\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 mutArray\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theArray's\cf0  \cf6 mutableCopy\cf0 ()\
	
\f0\b \cf0 repeat
\f1\b0 \cf0  
\f0\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f0\b \cf0 from
\f1\b0 \cf0  \cf0 0\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theArray's\cf0  \cf6 |count|\cf0 ()) - \cf0 1\cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 thisItem\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  (\cf5 theArray's\cf0  \cf6 objectAtIndex\cf0 :\cf5 i\cf0 )\
		
\f0\b \cf0 if
\f1\b0 \cf0  (\cf5 thisItem's\cf0  \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 NSDate\cf0 )) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
			(\cf5 mutArray's\cf0  \cf6 replaceObjectAtIndex\cf0 :\cf5 i\cf0  \cf6 withObject\cf0 :(
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _makeASDateFrom\cf0 :\cf5 thisItem\cf0 ))\
		
\f0\b \cf0 else
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0  (\cf5 thisItem's\cf0  \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 NSDictionary\cf0 )) 
\f0\b \cf0 as
\f1\b0 \cf0  
\f2\i \cf3 boolean
\f1\i0 \cf0  
\f0\b \cf0 then
\f1\b0 \cf0 \
			(\cf5 mutArray's\cf0  \cf6 replaceObjectAtIndex\cf0 :\cf5 i\cf0  \cf6 withObject\cf0 :(
\f0\b \cf0 my
\f1\b0 \cf0  \cf6 _convertDatesInDict\cf0 :\cf5 thisItem\cf0 ))\
		
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 repeat
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 mutArray\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 _convertDatesInArray\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Used for conversion of dates
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 _makeASDateFrom\cf0 :\cf5 theNSDate\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theCalendar\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSCalendar's\cf0  \cf6 currentCalendar\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theComponents\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theCalendar's\cf0  \cf6 components\cf0 :\cf0 252\cf0  \cf6 fromDate\cf0 :\cf5 theNSDate\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theYear\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 |year|\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMonth\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 |month|\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theDay\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 |day|\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theHour\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 hour\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theMinute\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 minute\cf0 ()\
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 theSeconds\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 theComponents's\cf0  \cf6 |second|\cf0 ()\
	
\f0\b \cf0 using terms from
\f1\b0 \cf0  
\f2\i \cf3 scripting additions
\f1\i0 \cf0 \
		
\f0\b \cf0 tell
\f1\b0 \cf0  (
\f0\b \cf3 current date
\f1\b0 \cf0 ) 
\f0\b \cf0 to
\f1\b0 \cf0  
\f0\b \cf0 set
\f1\b0 \cf0  \{\cf5 theASDate\cf0 , \cf2 year\cf0 , \cf2 day\cf0 , 
\f0\b \cf0 its
\f1\b0 \cf0  
\f2\i \cf3 month
\f1\i0 \cf0 , \cf2 day\cf0 , 
\f0\b \cf0 its
\f1\b0 \cf0  \cf2 hours\cf0 , 
\f0\b \cf0 its
\f1\b0 \cf0  \cf2 minutes\cf0 , 
\f0\b \cf0 its
\f1\b0 \cf0  
\f2\i \cf3 seconds
\f1\i0 \cf0 \} 
\f0\b \cf0 to
\f1\b0 \cf0  \{
\f0\b \cf0 it
\f1\b0 \cf0 , \cf5 theYear\cf0 , \cf0 1\cf0 , \cf5 theMonth\cf0 , \cf5 theDay\cf0 , \cf5 theHour\cf0 , \cf5 theMinute\cf0 , \cf5 theSeconds\cf0 \}\
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 using terms from
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf5 theASDate\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 _makeASDateFrom\cf6 :\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\i \cf4 -- Handler called by -fetchMetadata\'85 handlers
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf0 on
\f1\b0 \cf0  \cf6 _mdItemFrom\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 tempArray\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 fileAliasURLOrPosixPath\cf0 \
	
\f0\b \cf0 if
\f1\b0 \cf0  \cf5 tempArray's\cf0  \cf6 firstObject\cf0 ()'s \cf6 isKindOfClass\cf0 :(\cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 |class|\cf0 ()) 
\f0\b \cf0 then
\f1\b0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 targetURL\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf5 tempArray's\cf0  \cf6 firstObject\cf0 ()\
	
\f0\b \cf0 else
\f1\b0 \cf0 \
		
\f0\b \cf0 set
\f1\b0 \cf0  \cf5 targetURL\cf0  
\f0\b \cf0 to
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 |NSURL|'s\cf0  \cf6 fileURLWithPath\cf0 :(\cf2 POSIX path\cf0  
\f0\b \cf0 of
\f1\b0 \cf0  \cf5 fileAliasURLOrPosixPath\cf0 )\
	
\f0\b \cf0 end
\f1\b0 \cf0  
\f0\b \cf0 if
\f1\b0 \cf0 \
	
\f0\b \cf0 return
\f1\b0 \cf0  \cf2 current application's\cf0  \cf5 NSMetadataItem's\cf0  \cf6 alloc\cf0 ()'s \cf6 initWithURL\cf0 :\cf5 targetURL\cf0 \

\f0\b \cf0 end
\f1\b0 \cf0  \cf6 _mdItemFrom\cf6 :\cf0 \
\
}