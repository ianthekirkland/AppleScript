{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fnil\fcharset0 Verdana-Italic;\f1\fnil\fcharset0 Verdana;\f2\fnil\fcharset0 Verdana-Bold;
}
{\colortbl;\red255\green255\blue255;\red77\green78\blue78;\red108\green5\blue211;\red0\green0\blue255;
\red64\green128\blue0;\red251\green0\blue7;\red0\green22\blue176;}
{\*\expandedcolortbl;;\csgenericrgb\c30000\c30500\c30500;\csgenericrgb\c42300\c1800\c82800;\csgenericrgb\c0\c0\c99819;
\csgenericrgb\c25000\c50000\c0;\cssrgb\c100000\c0\c0;\csgenericrgb\c0\c8700\c69000;}
\deftab480
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i\fs24 \cf2 -- Created 2015-12-07 10:29:40 +1100 by Shane Stanley
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 use
\f1\b0 \cf0  \cf3 AppleScript\cf0  \cf4 version\cf0  \cf0 "2.5"\cf0  
\f0\i \cf2 -- requires OS X 10.11 or higher
\f1\i0 \cf0 \

\f2\b \cf0 use
\f1\b0 \cf0  
\f0\i \cf4 scripting additions
\f1\i0 \cf0 \

\f2\b \cf0 use
\f1\b0 \cf0  
\f0\i \cf4 framework
\f1\i0 \cf0  \cf0 "Foundation"\cf0 \

\f2\b \cf0 use
\f1\b0 \cf0  
\f0\i \cf4 framework
\f1\i0 \cf0  \cf0 "EventKit"\cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- You need to fetch the event store first; it's required for many other handlers. This also triggers authentication if needed.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 fetch store
\f1\b0 \cf0 \
	
\f0\i \cf2 -- create event store and get the OK to access Calendars
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEKEventStore\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKEventStore's\cf0  \cf6 alloc\cf0 ()'s \cf6 init\cf0 ()\
	\cf5 theEKEventStore's\cf0  \cf6 requestAccessToEntityType\cf0 :\cf0 0\cf0  \cf6 completion\cf0 :(
\f0\i \cf4 missing value
\f1\i0 \cf0 )\
	
\f0\i \cf2 -- check if app has access; this will still occur the first time you OK authorization
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 authorizationStatus\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKEventStore's\cf0  \cf6 authorizationStatusForEntityType\cf0 :\cf0 0\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 authorizationStatus\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  \cf0 3\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf7 display dialog
\f1\b0 \cf0  \cf0 "Access must be given in System Preferences"\cf0  & \cf3 linefeed\cf0  & \cf0 "-> Security & Privacy first."\cf0  \cf7 buttons\cf0  \{\cf0 "OK"\cf0 \} \cf7 default button\cf0  \cf0 1\cf0 \
		
\f2\b \cf0 tell
\f1\b0 \cf0  
\f0\i \cf4 application
\f1\i0 \cf0  \cf0 "System Preferences"\cf0 \
			
\f2\b \cf4 activate
\f1\b0 \cf0 \
			
\f2\b \cf0 tell
\f1\b0 \cf0  
\f0\i \cf4 pane
\f1\i0 \cf0  \cf3 id\cf0  \cf0 "com.apple.preference.security"\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  
\f2\b \cf4 reveal
\f1\b0 \cf0  
\f0\i \cf4 anchor
\f1\i0 \cf0  \cf0 "Privacy"\cf0 \
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 tell
\f1\b0 \cf0 \
		
\f2\b \cf0 error
\f1\b0 \cf0  \cf4 number\cf0  \cf0 -128\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEKEventStore\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 fetch store
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- You often need a reference to the relevant calendar; get it here.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 fetch calendar
\f1\b0 \cf0  \cf5 calName\cf0  \cf4 cal type\cf0  \cf5 calType\cf0  \cf4 event store\cf0  \cf5 theStore\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal local\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 0\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal cloud\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 1\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal exchange\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 2\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal subscription\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 3\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal birthday\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 4\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 error
\f1\b0 \cf0  \cf0 "Invalid cal type"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f0\i \cf2 -- get calendars that can store events
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theCalendars\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 calendarsForEntityType\cf0 :\cf0 0\cf0 \
	
\f0\i \cf2 -- get the requested calendar
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title == %@ AND type == %@"\cf0 , \cf5 calName\cf0 , \cf5 calType\cf0 )\
	
\f2\b \cf0 return
\f1\b0 \cf0  (\cf5 theCalendars's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 theNSPredicate\cf0 )'s \cf6 firstObject\cf0 ()\

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 fetch calendar
\f1\b0 \cf0 \
\

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 fetch calendars
\f1\b0 \cf0  \cf5 listOfCalNames\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0  \cf4 cal type list\cf0  \cf5 listOfCalTypes\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0  : \{\} \cf4 event store\cf0  \cf5 theStore\cf0 \
	
\f0\i \cf2 -- get calendars that can store events
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theCalendars\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 calendarsForEntityType\cf0 :\cf0 0\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 listOfCalTypes\cf0  = \{\} 
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 listOfCalNames\cf0  = \{\} 
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theCalendars\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \
		
\f2\b \cf0 else
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title IN %@"\cf0 , \cf5 listOfCalNames\cf0 )\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 repeat
\f1\b0 \cf0  
\f2\b \cf0 with
\f1\b0 \cf0  \cf5 i\cf0  
\f2\b \cf0 from
\f1\b0 \cf0  \cf0 1\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  
\f2\b \cf4 count
\f1\b0 \cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 listOfCalTypes\cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  
\f0\i \cf4 item
\f1\i0 \cf0  \cf5 i\cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 listOfCalTypes\cf0 \
			
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal local\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 0\cf0 \
			
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal cloud\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 1\cf0 \
			
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal exchange\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 2\cf0 \
			
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal subscription\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 3\cf0 \
			
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 calType\cf0  = \cf3 cal birthday\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 4\cf0 \
			
\f2\b \cf0 else
\f1\b0 \cf0 \
				
\f2\b \cf0 error
\f1\b0 \cf0  \cf0 "Invalid cal type"\cf0 \
			
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  
\f0\i \cf4 item
\f1\i0 \cf0  \cf5 i\cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 listOfCalTypes\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 calType\cf0 \
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 repeat
\f1\b0 \cf0 \
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 listOfCalNames\cf0  = \{\} 
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "type IN %@"\cf0 , \cf5 listOfCalTypes\cf0 )\
		
\f2\b \cf0 else
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title IN %@ AND type IN %@"\cf0 , \cf5 listOfCalNames\cf0 , \cf5 listOfCalTypes\cf0 )\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  (\cf5 theCalendars's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 theNSPredicate\cf0 ) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 fetch calendars
\f1\b0 \cf0 \
\
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- In theory, more than one event can have the same external ID, so this returns a list of events.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 fetch events by UID
\f1\b0 \cf0  \cf5 calID\cf0  \cf4 event store\cf0  \cf5 theStore\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theStore's\cf0  \cf6 calendarItemsWithExternalIdentifier\cf0 :\cf5 calID\cf0 )\
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvents's\cf0  \cf6 sortedArrayUsingSelector\cf0 :\cf0 "compareStartDateWithEvent:"\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 fetch events by UID
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- The main way to search for events. Dates can be AS dates or NSDates.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 fetch events
\f1\b0 \cf0  \cf4 starting date\cf0  \cf5 startDate\cf0  \cf4 ending date\cf0  \cf5 endDate\cf0  \cf4 searching cals\cf0  \cf5 calList\cf0  \cf4 event store\cf0  \cf5 theStore\cf0 \
	
\f0\i \cf2 -- check it it is a list/array of calendars, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calListArray\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 calList\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calList\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 calListArray's\cf0  \cf6 |firstObject|\cf0 ()\
	
\f2\b \cf0 if
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  (\cf5 calList's\cf0  \cf6 isKindOfClass\cf0 :(\cf3 current application's\cf0  \cf5 NSArray\cf0 )) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 calList\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 calListArray\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 thePredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 predicateForEventsWithStartDate\cf0 :\cf5 startDate\cf0  \cf6 endDate\cf0 :\cf5 endDate\cf0  \cf6 calendars\cf0 :\cf5 calList\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 eventsMatchingPredicate\cf0 :\cf5 thePredicate\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvents's\cf0  \cf6 sortedArrayUsingSelector\cf0 :\cf0 "compareStartDateWithEvent:"\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 fetch events
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- If you have retrieved events, you can use this to refine the resulting list. Summary, location, and description are case-insensitive strings; the other parameters are booleans. Pass missing value for parameters you're not interested in.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 filter events
\f1\b0 \cf0  \cf4 event list\cf0  \cf5 theEvents\cf0  \cf4 event summary\cf0  \cf5 theTitle\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event location\cf0  \cf5 theLocation\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event description\cf0  \cf5 desc\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 has attendees\cf0  \cf5 hasA\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 has recurrence\cf0  \cf5 hasRecRules\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 runs all day\cf0  \cf5 allDay\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0 \
	
\f0\i \cf2 -- check it it is a list/array of events, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEventsArray\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 theEvents\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEventsArray's\cf0  \cf6 |firstObject|\cf0 ()\
	
\f2\b \cf0 if
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 isKindOfClass\cf0 :(\cf3 current application's\cf0  \cf5 NSArray\cf0 )) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEventsArray\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 predArray\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSMutableArray's\cf0  \cf6 arrayWithCapacity\cf0 :\cf0 6\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theTitle\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title ==[c] %@"\cf0 , \cf5 theTitle\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theLocation\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "location ==[c] %@"\cf0 , \cf5 theLocation\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 desc\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "hasNotes == %@ AND notes ==[c] %@"\cf0 , \cf3 true\cf0 , \cf5 desc\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 hasA\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "hasAttendees == %@"\cf0 , \cf5 hasA\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 hasRecRules\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "hasRecurrenceRules == %@"\cf0 , \cf5 hasRecRules\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 allDay\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 predArray's\cf0  \cf6 addObject\cf0 :(\cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "allDay == %@"\cf0 , \cf5 allDay\cf0 ))\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theCount\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  
\f2\b \cf4 count
\f1\b0 \cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 predArray\cf0 \
	
\f0\i \cf2 -- do nothing if count is 0; if 1, just use the first predicate in the array; otherwise and them all
\f1\i0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theCount\cf0  = \cf0 1\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :(\cf5 predArray's\cf0  \cf6 firstObject\cf0 ()))\
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theCount\cf0  > \cf0 1\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 thePred\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSCompoundPredicate's\cf0  \cf6 andPredicateWithSubpredicates\cf0 :\cf5 predArray\cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 thePred\cf0 )\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 filter events
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- When you have retrieved events, you can use this to refine the resulting list. If useRegex is true, the string(s) you pass will be treated as regular expression patterns, and matches will be sought. If useRegex is false, you can use ? as a wildcard for single characters and * as a wildcard for zero or more characters. Pass missing value for parameters you're not interested in.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 filter events by pattern
\f1\b0 \cf0  \cf4 event list\cf0  \cf5 theEvents\cf0  \cf4 event summary\cf0  \cf5 theTitle\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event description\cf0  \cf5 desc\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event location\cf0  \cf5 theLocation\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 using regex\cf0  \cf5 regexFlag\cf0  : \cf3 true\cf0 \
	
\f0\i \cf2 -- check it it is a list/array of events, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEventsArray\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 theEvents\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEventsArray's\cf0  \cf6 |firstObject|\cf0 ()\
	
\f2\b \cf0 if
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 isKindOfClass\cf0 :(\cf3 current application's\cf0  \cf5 NSArray\cf0 )) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEventsArray\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theTitle\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 regexFlag\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title MATCHES %@"\cf0 , \cf5 theTitle\cf0 )\
		
\f2\b \cf0 else
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "title LIKE %@"\cf0 , \cf5 theTitle\cf0 )\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 theNSPredicate\cf0 )\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 desc\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 regexFlag\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "hasNotes == %@ AND notes MATCHES %@"\cf0 , \cf3 true\cf0 , \cf5 desc\cf0 )\
		
\f2\b \cf0 else
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "hasNotes == %@ AND notes LIKE %@"\cf0 , \cf3 true\cf0 , \cf5 desc\cf0 )\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 theNSPredicate\cf0 )\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theLocation\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 useRegex\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "location MATCHES %@"\cf0 , \cf5 theLocation\cf0 )\
		
\f2\b \cf0 else
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNSPredicate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSPredicate's\cf0  \cf6 predicateWithFormat_\cf0 (\cf0 "location LIKE %@"\cf0 , \cf5 theLocation\cf0 )\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvents's\cf0  \cf6 filteredArrayUsingPredicate\cf0 :\cf5 theNSPredicate\cf0 )\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvents\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 filter events by pattern
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- Deletes an event. For recurring events, futureFlag should be true to delete future recurrences.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 remove event
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0  \cf4 event store\cf0  \cf5 theStore\cf0  \cf4 future events\cf0  \cf5 futureFlag\cf0  : \cf3 true\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \{\cf5 theResult\cf0 , \cf5 theError\cf0 \} 
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 removeEvent\cf0 :\cf5 theEvent\cf0  \cf6 span\cf0 :\cf5 futureFlag\cf0  \cf6 commit\cf0 :\cf3 true\cf0  \cf6 |error|\cf0 :(
\f0\i \cf4 specifier
\f1\i0 \cf0 )\
	
\f2\b \cf0 if
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  
\f2\b \cf0 error
\f1\b0 \cf0  (\cf5 theError's\cf0  \cf6 localizedDescription\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 text
\f1\i0 \cf0 )\

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 remove event
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- Creates a new event. Location and notes can be missing value, start and end dates can be AS dates or NSDates, and allDay is a boolean. You still need to save it using the saveEvent::: handler below.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 create event
\f1\b0 \cf0  \cf4 event store\cf0  \cf5 theStore\cf0  \cf4 destination calendar\cf0  \cf5 theCal\cf0  \cf4 event summary\cf0  \cf5 theTitle\cf0  \cf4 starting date\cf0  \cf5 startD\cf0  \cf4 ending date\cf0  \cf5 endD\cf0  \cf4 runs all day\cf0  \cf5 allDay\cf0  : \cf3 false\cf0  \cf4 event location\cf0  \cf5 theLocation\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event description\cf0  \cf5 desc\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 newEvent\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKEvent's\cf0  \cf6 eventWithEventStore\cf0 :\cf5 theStore\cf0 \
	\cf5 newEvent's\cf0  \cf6 setCalendar\cf0 :\cf5 theCal\cf0 \
	\cf5 newEvent's\cf0  \cf6 setTitle\cf0 :\cf5 theTitle\cf0 \
	\cf5 newEvent's\cf0  \cf6 setStartDate\cf0 :\cf5 startD\cf0 \
	\cf5 newEvent's\cf0  \cf6 setEndDate\cf0 :\cf5 endD\cf0 \
	\cf5 newEvent's\cf0  \cf6 setAllDay\cf0 :\cf5 allDay\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theLocation\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 newEvent's\cf0  \cf6 setLocation\cf0 :\cf5 theLocation\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 desc\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 newEvent's\cf0  \cf6 setNotes\cf0 :\cf5 desc\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 newEvent\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 create event
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- Supply missing value for properties you do not want to change.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 modify event
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0  \cf4 destination calendar\cf0  \cf5 theCal\cf0  \cf4 event summary\cf0  \cf5 theTitle\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 starting date\cf0  \cf5 startD\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 ending date\cf0  \cf5 endD\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 runs all day\cf0  \cf5 allDay\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event location\cf0  \cf5 theLocation\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 event description\cf0  \cf5 desc\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theCal\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setCalendar\cf0 :\cf5 theCal\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theTitle\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setTitle\cf0 :\cf5 theTitle\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 startD\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setStartDate\cf0 :\cf5 startD\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 endD\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setEndDate\cf0 :\cf5 endD\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 allDay\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setAllDay\cf0 :\cf5 allDay\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theLocation\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setLocation\cf0 :\cf5 theLocation\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 desc\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 setNotes\cf0 :\cf5 desc\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvent\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 modify event
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- The time zone can be missing value (for floating times), a valid time zone name, or a Cocoa NSTimeZone.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 modify zone
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0  \cf4 time zone\cf0  \cf5 tz\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 tz\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 theEvent's\cf0  \cf6 setTimeZone\cf0 :\cf5 tz\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f0\i \cf2 -- workaround to make sure tz is a Cocoa object so we can test its class
\f1\i0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 tz\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf3 current application's\cf0  \cf5 NSArray's\cf0  \cf6 arrayWithObject\cf0 :\cf5 tz\cf0 )'s \cf6 |firstObject|\cf0 ()\
		
\f2\b \cf0 if
\f1\b0 \cf0  (\cf5 tz's\cf0  \cf6 isKindOfClass\cf0 :(\cf3 current application's\cf0  \cf5 NSString\cf0 )) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f0\i \cf2 -- make a time zone from string if possible
\f1\i0 \cf0 \
			
\f2\b \cf0 if
\f1\b0 \cf0  (\cf3 current application's\cf0  \cf5 NSTimeZone's\cf0  \cf6 knownTimeZoneNames\cf0 ()'s \cf6 containsObject\cf0 :\cf5 tz\cf0 ) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
				
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 tz\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSTimeZone's\cf0  \cf6 timeZoneWithName\cf0 :\cf5 tz\cf0 \
				\cf5 theEvent's\cf0  \cf6 setTimeZone\cf0 :\cf5 tz\cf0 \
			
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
		
\f2\b \cf0 else
\f1\b0 \cf0  
\f0\i \cf2 -- assume it's already a time zone
\f1\i0 \cf0 \
			\cf5 theEvent's\cf0  \cf6 setTimeZone\cf0 :\cf5 tz\cf0 \
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvent\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 modify zone
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- You pass the frequency as an integer or string, and the interval as an integer. If you supply a date (AS date or NSDate) for orEndDate:, it will be used, otherwise pass missing value for it, and the repeatCount: integer will be used.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 modify recurrence
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0  \cf4 event frequency\cf0  \cf5 theFreq\cf0  \cf4 event interval\cf0  \cf5 interv\cf0  \cf4 repeats for\cf0  \cf5 repeatCt\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0  \cf4 repeats until\cf0  \cf5 endingDate\cf0  : 
\f0\i \cf4 missing value
\f1\i0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theFreq\cf0  = \cf3 do daily\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theFreq\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 0\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theFreq\cf0  = \cf3 do weekly\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theFreq\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 1\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theFreq\cf0  = \cf3 do monthly\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theFreq\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 2\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theFreq\cf0  = \cf3 do yearly\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theFreq\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf0 3\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 error
\f1\b0 \cf0  \cf0 "Invalid frequency parameter"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 endingDate\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrEnd\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKRecurrenceEnd's\cf0  \cf6 recurrenceEndWithOccurrenceCount\cf0 :\cf5 repeatCt\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrEnd\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKRecurrenceEnd's\cf0  \cf6 recurrenceEndWithEndDate\cf0 :\cf5 endingDate\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrRule\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 EKRecurrenceRule's\cf0  \cf6 alloc\cf0 ()'s \cf6 initRecurrenceWithFrequency\cf0 :\cf5 theFreq\cf0  \cf6 interval\cf0 :\cf5 interv\cf0  \cf6 |end|\cf0 :\cf5 recurrEnd\cf0 \
	
\f0\i \cf2 -- delete any existing first
\f1\i0 \cf0 \
	
\f2\b \cf4 stop recurrence
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	\cf5 theEvent's\cf0  \cf6 addRecurrenceRule\cf0 :\cf5 recurrRule\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvent\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 modify recurrence
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- Turns off recurrence for event.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 stop recurrence
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 hasRecurrenceRules\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theRules\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 |recurrenceRules|\cf0 ()\
		
\f2\b \cf0 if
\f1\b0 \cf0  (
\f2\b \cf4 count
\f1\b0 \cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 theRules\cf0 ) > \cf0 0\cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 removeRecurrenceRule\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  \cf0 1\cf0  
\f2\b \cf0 of
\f1\b0 \cf0  \cf5 theRules\cf0 )\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvent\cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 stop recurrence
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- After you create or modify an event, you need to save it. For recurring events, futureFlag should be true to make changes apply to future events.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 store event
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0  \cf4 event store\cf0  \cf5 theStore\cf0  \cf4 future events\cf0  \cf5 futureFlag\cf0  : \cf3 true\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \{\cf5 theResult\cf0 , \cf5 theError\cf0 \} 
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theStore's\cf0  \cf6 saveEvent\cf0 :\cf5 theEvent\cf0  \cf6 span\cf0 :\cf5 futureFlag\cf0  \cf6 commit\cf0 :\cf3 true\cf0  \cf6 |error|\cf0 :(
\f0\i \cf4 specifier
\f1\i0 \cf0 )\
	
\f2\b \cf0 if
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  
\f2\b \cf0 error
\f1\b0 \cf0  (\cf5 theError's\cf0  \cf6 |localizedDescription|\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 text
\f1\i0 \cf0 )\

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 store event
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- This is the external id used by Calendar.app.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 event identifier for
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 |calendarItemExternalIdentifier|\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 text
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 event identifier for
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- returns record.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 event info for
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	
\f0\i \cf2 -- work around problem with null values in dictionaries; set initial nulls for all values that might be missing value
\f1\i0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNull\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSNull's\cf0  \cf6 |null|\cf0 ()\
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theDict\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSMutableDictionary's\cf0  \cf6 dictionaryWithObjects\cf0 :\{\cf5 theNull\cf0 , \cf5 theNull\cf0 , \cf5 theNull\cf0 , \cf5 theNull\cf0 , \cf5 theNull\cf0 , \cf5 theNull\cf0 , \cf5 theNull\cf0 \} \cf6 forKeys\cf0 :\{\cf0 "event_summary"\cf0 , \cf0 "event_time_zone"\cf0 , \cf0 "event_location"\cf0 , \cf0 "event_url"\cf0 , \cf0 "event_description"\cf0 , \cf0 "event_organizer"\cf0 , \cf0 "event_original_date"\cf0 \}\
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 calendar\cf0 ()'s \cf6 title\cf0 ()) \cf6 forKey\cf0 :\cf0 "calendar_name"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 calendar\cf0 ()'s \cf6 |type|\cf0 ()) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theResult\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "local"\cf0 , \cf0 "cloud"\cf0 , \cf0 "Exchange"\cf0 , \cf0 "subscription"\cf0 , \cf0 "birthday"\cf0 \}) \cf6 forKey\cf0 :\cf0 "calendar_type"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 title\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 theResult\cf0  \cf6 forKey\cf0 :\cf0 "event_summary"\cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |calendarItemExternalIdentifier|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_external_ID"\cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |startDate|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_start_date"\cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |endDate|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_end_date"\cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |isAllDay|\cf0 ()) \cf6 forKey\cf0 :\cf0 "all_day"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 tz\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 timeZone\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 tz\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 tz's\cf0  \cf6 |name|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_time_zone"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 location\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 theResult\cf0  \cf6 forKey\cf0 :\cf0 "event_location"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theURL\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 |URL|\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theURL\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theURL's\cf0  \cf6 |absoluteString|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_url"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 |hasNotes|\cf0 ()) 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 notes\cf0 ())\
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 theResult\cf0  \cf6 forKey\cf0 :\cf0 "event_description"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theAttendees\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 |hasAttendees|\cf0 ()\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theAttendees\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 attendees\cf0 ()'s \cf6 valueForKey\cf0 :\cf0 "name"\cf0 ) \cf6 forKey\cf0 :\cf0 "event_attendees"\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		\cf5 theDict's\cf0  \cf6 setObject\cf0 :\{\} \cf6 forKey\cf0 :\cf0 "event_attendees"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |hasRecurrenceRules|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_is_recurring"\cf0 \
	\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEvent's\cf0  \cf6 |creationDate|\cf0 ()) \cf6 forKey\cf0 :\cf0 "event_creation_date"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 organizer\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theResult's\cf0  \cf6 |name|\cf0 ())\
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 theResult\cf0  \cf6 forKey\cf0 :\cf0 "event_organizer"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 |occurrenceDate|\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 theResult\cf0  \cf6 forKey\cf0 :\cf0 "event_original_date"\cf0 \
	
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf5 theEvent's\cf0  \cf6 status\cf0 ())\
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		\cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf0 "none"\cf0  \cf6 forKey\cf0 :\cf0 "event_status"\cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theResult\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
		\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theResult\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "none"\cf0 , \cf0 "confirmed"\cf0 , \cf0 "tentative"\cf0 , \cf0 "canceled"\cf0 \}) \cf6 forKey\cf0 :\cf0 "event_status"\cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theDict\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 record
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 event info for
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- returns a list of records
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 event attendees for
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 hasAttendees\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNull\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSNull's\cf0  \cf6 |null|\cf0 ()\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theAttendees\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 attendees\cf0 ()\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theArray\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSMutableArray's\cf0  \cf6 array\cf0 ()\
		
\f2\b \cf0 repeat
\f1\b0 \cf0  
\f2\b \cf0 with
\f1\b0 \cf0  \cf5 anAttendee\cf0  
\f2\b \cf0 in
\f1\b0 \cf0  \cf5 theAttendees\cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theDict\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf3 current application's\cf0  \cf5 NSMutableDictionary's\cf0  \cf6 dictionaryWithObjects\cf0 :\{\cf5 theNull\cf0 \} \cf6 forKeys\cf0 :\{\cf0 "attendee_email"\cf0 \})\
			(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 anAttendee's\cf0  \cf6 |name|\cf0 ()) \cf6 forKey\cf0 :\cf0 "attendee_name"\cf0 )\
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theEmail\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 anAttendee's\cf0  \cf6 |URL|\cf0 ()\
			
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theEmail\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  (\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theEmail's\cf0  \cf6 |resourceSpecifier|\cf0 ()) \cf6 forKey\cf0 :\cf0 "attendee_email"\cf0 )\
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theStatus\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 anAttendee's\cf0  \cf6 |participantStatus|\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
			(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theStatus\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "unknown"\cf0 , \cf0 "pending"\cf0 , \cf0 "accepted"\cf0 , \cf0 "declined"\cf0 , \cf0 "tentative"\cf0 , \cf0 "delegated"\cf0 , \cf0 "completed"\cf0 , \cf0 "in process"\cf0 \}) \cf6 forKey\cf0 :\cf0 "attendee_status"\cf0 )\
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theType\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 anAttendee's\cf0  \cf6 |participantType|\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
			(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theType\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "unknown"\cf0 , \cf0 "person"\cf0 , \cf0 "room"\cf0 , \cf0 "resource"\cf0 , \cf0 "group"\cf0 \}) \cf6 forKey\cf0 :\cf0 "attendee_type"\cf0 )\
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theRole\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 anAttendee's\cf0  \cf6 |participantRole|\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
			(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theRole\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "unknown"\cf0 , \cf0 "required"\cf0 , \cf0 "optional"\cf0 , \cf0 "chair"\cf0 , \cf0 "nonparticipant"\cf0 \}) \cf6 forKey\cf0 :\cf0 "attendee_role"\cf0 )\
			(\cf5 theArray's\cf0  \cf6 addObject\cf0 :(\cf5 theDict's\cf0  \cf6 |copy|\cf0 ()))\
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 repeat
\f1\b0 \cf0 \
		
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theArray\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 list
\f1\i0 \cf0 \
	
\f2\b \cf0 else
\f1\b0 \cf0 \
		
\f2\b \cf0 return
\f1\b0 \cf0  \{\}\
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 event attendees for
\f1\b0 \cf0 \
\
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\i \cf2 -- Returns a record. If occurrence_end_date is missing value, occurrence_frequency is used.
\f1\i0 \cf0 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f2\b \cf0 on
\f1\b0 \cf0  
\f2\b \cf4 event recurrence for
\f1\b0 \cf0  \cf4 event\cf0  \cf5 theEvent\cf0 \
	
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 hasRecurrenceRules\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 boolean
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theNull\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf3 current application's\cf0  \cf5 NSNull's\cf0  \cf6 |null|\cf0 ()\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theDict\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  (\cf3 current application's\cf0  \cf5 NSMutableDictionary's\cf0  \cf6 dictionaryWithObjects\cf0 :\{\cf5 theNull\cf0 \} \cf6 forKeys\cf0 :\{\cf0 "occurrence_end_date"\cf0 \})\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theRule\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theEvent's\cf0  \cf6 |recurrenceRules|\cf0 ()'s \cf6 firstObject\cf0 ()\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 theFreq\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theRule's\cf0  \cf6 frequency\cf0 () 
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 integer
\f1\i0 \cf0 \
		(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(
\f0\i \cf4 item
\f1\i0 \cf0  (\cf5 theFreq\cf0  + \cf0 1\cf0 ) 
\f2\b \cf0 of
\f1\b0 \cf0  \{\cf0 "daily"\cf0 , \cf0 "weekly"\cf0 , \cf0 "monthly"\cf0 , \cf0 "yearly"\cf0 \}) \cf6 forKey\cf0 :\cf0 "occurrence_frequency"\cf0 )\
		(\cf5 theDict's\cf0  \cf6 setObject\cf0 :(\cf5 theRule's\cf0  \cf6 interval\cf0 ()) \cf6 forKey\cf0 :\cf0 "occurrence_interval"\cf0 )\
		
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrEnd\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 theRule's\cf0  \cf6 |recurrenceEnd|\cf0 ()\
		
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 recurrEnd\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrEndDate\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 recurrEnd's\cf0  \cf6 |endDate|\cf0 ()\
			
\f2\b \cf0 if
\f1\b0 \cf0  \cf5 recurrEndDate\cf0  
\f2\b \cf0 is
\f1\b0 \cf0  
\f2\b \cf0 not
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0  
\f2\b \cf0 then
\f1\b0 \cf0  \cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 recurrEndDate\cf0  \cf6 forKey\cf0 :\cf0 "occurrence_end_date"\cf0 \
			
\f2\b \cf0 set
\f1\b0 \cf0  \cf5 recurrCount\cf0  
\f2\b \cf0 to
\f1\b0 \cf0  \cf5 recurrEnd's\cf0  \cf6 |occurrenceCount|\cf0 ()\
			\cf5 theDict's\cf0  \cf6 setObject\cf0 :\cf5 recurrCount\cf0  \cf6 forKey\cf0 :\cf0 "occurrence_count"\cf0 \
		
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
		
\f2\b \cf0 return
\f1\b0 \cf0  \cf5 theDict\cf0  
\f2\b \cf0 as
\f1\b0 \cf0  
\f0\i \cf4 record
\f1\i0 \cf0 \
	
\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf0 if
\f1\b0 \cf0 \
	
\f2\b \cf0 return
\f1\b0 \cf0  
\f0\i \cf4 missing value
\f1\i0 \cf0 \

\f2\b \cf0 end
\f1\b0 \cf0  
\f2\b \cf4 event recurrence for
\f1\b0 \cf0 \
}